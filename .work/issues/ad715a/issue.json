{
  "id": "ad715a",
  "title": "Explore: Global --help support for all commands",
  "status": "done",
  "type": "feature",
  "priority": 2,
  "labels": [
    "explore"
  ],
  "created": "2026-02-15T21:12:36.501476Z",
  "updated": "2026-02-15T21:16:39.835935Z",
  "description": "# Global --help Support for All Commands\n\n## Current State\n\n**Framework**: None — hand-rolled CLI in `main.go` (~914 lines).\nCommand routing via `switch` on `os.Args[1]`. Custom `parseFlags()`\nfor `--key=value` pairs. Zero external deps.\n\n**18 commands** registered as `case` branches. Each maps to a\n`cmd*()` function.\n\n### Existing Help\n\n- `printHelp()` prints command summary to **stderr** with exit 1\n  (error semantics) when no args given\n- Some commands print one-line usage on missing positional args\n  (also stderr, exit 1)\n- **No `--help` flag** — `parseFlags()` treats it as value flag,\n  consuming next positional arg as its \"value\"\n- **No `help` subcommand** — `work help` → \"unknown command\"\n- `booleanFlags` map only contains `\"roots\"`, not `\"help\"`\n- Commands without required positional args (`init`, `list`,\n  `export`, `history`) have no usage path at all\n- Command lists duplicated in 4 places: `main()` switch,\n  `printHelp()`, bash completions, zsh completions\n\n## Recommendation\n\nAdd lightweight help system without introducing a framework.\nKeep the hand-rolled approach. Define `command` struct per command\n(name, summary, usage, handler). Register in slice/map instead of\nswitch. Print help to **stdout** with exit **0** (standard\nconvention).\n\n## Execution Plan\n\n**Phase 1: Command registry data structure**\n1. Create `command` struct: Name, Summary, Usage, Run func()\n2. Build `[]command` or `map[string]command` for all 18 commands\n3. Replace `main()` switch with registry lookup\n4. Verify existing behavior preserved (`go test ./...`)\n\n**Phase 2: Add `--help` flag recognition**\n5. Add `\"help\"` to `booleanFlags` map\n6. Create `wantsHelp(flags)` helper\n7. In each `cmd*()`, check `wantsHelp` → print usage + exit 0\n8. Test: `work create --help`, `work list --help` produce help\n\n**Phase 3: Add `help` subcommand**\n9. Add `\"help\"` case to command dispatch\n10. `work help` → top-level help (stdout, exit 0)\n11. `work help \u003ccmd\u003e` → per-command help (stdout, exit 0)\n12. `work help \u003cunknown\u003e` → error (stderr, exit 1)\n13. Update shell completions to include `help`\n\n**Phase 4: Detailed per-command help text**\n14. Write multi-line help per command: synopsis, flags,\n    valid values, examples\n15. Add help text for commands that lack it: init, list,\n    export, history\n16. Replace inline usage strings with registry Usage field\n\n**Phase 5: Centralize help dispatch**\n17. Move `--help` check to central pre-dispatch hook\n18. Both `work \u003ccmd\u003e --help` and `work help \u003ccmd\u003e` use\n    same code path\n19. Error-path usage (missing args) → same text, stderr, exit 1\n\n**Phase 6: Eliminate duplicated command lists**\n20. Generate `printHelp()` output from registry\n21. Generate bash/zsh completions from registry\n22. Single source of truth: new command = one registry entry\n\n**Phase 7: Add `-h` shorthand**\n23. Add `-h` as alias for `--help`\n24. Update `parseFlags` for single-dash boolean flags\n25. Verify `work -h`, `work create -h` both work",
  "comments": [
    {
      "text": "Created issues: 2aad54, 68370c, 4d3f9c, 174456, 5e8d18, ecc599, a29b8c",
      "created": "2026-02-15T21:16:39.817054Z",
      "by": "Jim Myers"
    }
  ]
}